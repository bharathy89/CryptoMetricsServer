# coding: utf-8

from __future__ import absolute_import

import time
from datetime import date, datetime  # noqa: F401

from typing import List, Dict  # noqa: F401

import requests

from custom_logger import custom_logger
from swagger_server.models.base_model_ import Model
from swagger_server.models.condition import Condition  # noqa: F401,E501
from swagger_server import util
from swagger_server.models.util import get_db

logger = custom_logger.get_module_logger(__name__)

db = get_db()
table = db["monitors_table"]
GREATER_THAN = "greater_than"
LESS_THAN = "less_than"
NOTIFY_INTERVAL = 10 * 60  # 10 minutes


class Monitor(Model):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    def __init__(
        self,
        monitor_id: str = None,
        condition: Condition = None,
        active: bool = None,
        last_notified: float = None,
        notify_webhook: str = None,
        sample_interval: str = None,
    ):  # noqa: E501
        """Monitor - a model defined in Swagger

        :param monitor_id: The monitor_id of this Monitor.  # noqa: E501
        :type monitor_id: str
        :param condition: The condition of this Monitor.  # noqa: E501
        :type condition: Condition
        :param active: The active of this Monitor.  # noqa: E501
        :type active: bool
        :param last_notified: The last_notified of this Monitor.  # noqa: E501
        :type last_notified: float
        :param notify_webhook: The notify_webhook of this Monitor.  # noqa: E501
        :type notify_webhook: str
        :param sample_interval: The sample_interval of this Monitor.  # noqa: E501
        :type sample_interval: str
        """
        self.swagger_types = {
            "monitor_id": str,
            "condition": Condition,
            "active": bool,
            "last_notified": float,
            "notify_webhook": str,
            "sample_interval": str,
        }

        self.attribute_map = {
            "monitor_id": "monitor_id",
            "condition": "condition",
            "active": "active",
            "last_notified": "last_notified",
            "notify_webhook": "notify_webhook",
            "sample_interval": "sample_interval",
        }
        self._monitor_id = monitor_id
        self._condition = condition
        self._active = active
        self._last_notified = last_notified
        self._notify_webhook = notify_webhook
        self._sample_interval = sample_interval

    @classmethod
    def from_dict(cls, dikt) -> "Monitor":
        """Returns the dict as a model

        :param dikt: A dict.
        :type: dict
        :return: The Monitor of this Monitor.  # noqa: E501
        :rtype: Monitor
        """
        return util.deserialize_model(dikt, cls)

    @property
    def monitor_id(self) -> str:
        """Gets the monitor_id of this Monitor.


        :return: The monitor_id of this Monitor.
        :rtype: str
        """
        return self._monitor_id

    @monitor_id.setter
    def monitor_id(self, monitor_id: str):
        """Sets the monitor_id of this Monitor.


        :param monitor_id: The monitor_id of this Monitor.
        :type monitor_id: str
        """

        self._monitor_id = monitor_id

    @property
    def condition(self) -> Condition:
        """Gets the condition of this Monitor.


        :return: The condition of this Monitor.
        :rtype: Condition
        """
        return self._condition

    @condition.setter
    def condition(self, condition: Condition):
        """Sets the condition of this Monitor.


        :param condition: The condition of this Monitor.
        :type condition: Condition
        """

        self._condition = condition

    @property
    def active(self) -> bool:
        """Gets the active of this Monitor.


        :return: The active of this Monitor.
        :rtype: bool
        """
        return self._active

    @active.setter
    def active(self, active: bool):
        """Sets the active of this Monitor.


        :param active: The active of this Monitor.
        :type active: bool
        """

        self._active = active

    @property
    def last_notified(self) -> float:
        """Gets the last_notified of this Monitor.


        :return: The last_notified of this Monitor.
        :rtype: float
        """
        return self._last_notified

    @last_notified.setter
    def last_notified(self, last_notified: float):
        """Sets the last_notified of this Monitor.


        :param last_notified: The last_notified of this Monitor.
        :type last_notified: float
        """

        self._last_notified = last_notified

    @property
    def notify_webhook(self) -> str:
        """Gets the notify_webhook of this Monitor.


        :return: The notify_webhook of this Monitor.
        :rtype: str
        """
        return self._notify_webhook

    @notify_webhook.setter
    def notify_webhook(self, notify_webhook: str):
        """Sets the notify_webhook of this Monitor.


        :param notify_webhook: The notify_webhook of this Monitor.
        :type notify_webhook: str
        """

        self._notify_webhook = notify_webhook

    @property
    def sample_interval(self) -> str:
        """Gets the sample_interval of this Monitor.


        :return: The sample_interval of this Monitor.
        :rtype: str
        """
        return self._sample_interval

    @sample_interval.setter
    def sample_interval(self, sample_interval: str):
        """Sets the sample_interval of this Monitor.


        :param sample_interval: The sample_interval of this Monitor.
        :type sample_interval: str
        """
        allowed_values = ["1h", "1m", "1s"]  # noqa: E501
        if sample_interval not in allowed_values:
            raise ValueError(
                "Invalid value for `sample_interval` ({0}), must be one of {1}".format(
                    sample_interval, allowed_values
                )
            )

        self._sample_interval = sample_interval

    def call_webhook(self):
        current_time = time.time()
        if not self.active or self.last_notified < current_time - NOTIFY_INTERVAL:
            data_map = {
                "condition": self.condition,
                "message": "The monitor is firing",
            }
            response = requests.post(self.notify_webhook, data=data_map)
            if not response.ok:
                logger.error(
                    "failed to notify webhook: "
                    + self.to_str()
                    + " \nresponse: "
                    + response.text
                )
                raise Exception("failed to notify")
            return current_time
        return 0

    @classmethod
    def list(cls, metric_id="", offset=0, max_number=100) -> list:
        cursor = None
        if metric_id:
            cursor = table.find({"metric_id": metric_id}).skip(offset).limit(max_number)
        else:
            cursor = table.find().skip(offset).limit(max_number)

        items = []
        for item in cursor:
            items.append(Monitor.from_dict(item))
        return items

    @classmethod
    def load(cls, monitor_id: str) -> "Monitor":
        cursor = table.find_one({"monitor_id": monitor_id})
        item = {}
        if cursor:
            item = Monitor.from_dict(cursor)
        return item

    def save(self):
        res = table.update_one(
            {"monitor_id": self.monitor_id},
            {
                "$set": self.to_dict(),
            },
            upsert=True,
        )
        return res
